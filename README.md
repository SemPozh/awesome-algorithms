# nth_element
Алгоритм поиска n-го элемента на Java с использованием метода IntroSelect

## Запуск
`git clone`

`mvn test` - запуск бенчмарков и стресс тестов

## Структура проекта
Проект содержит один утилитный класс `SortingAlgorithms`, в котором есть один публичный статический метод `SortingAlgorithms.nthElement(T[] arr, int n)`
Метод ставит на позицию n в массиве arr тот элемент, который должен был бы стоять там, если бы массив был отсортирован.
Как видно, метод работает с параметризованным типом T, который должен наследовать класс Comparable. Это необходимо для попарного сравнения элементов.

## Анализ результатов
Для более точного анализа производительности кода производится несколько прогревочных операций, которые дают время оптимизировать код JIT. Затем несколько раз запускается алгоритм, результаты по времени усредняются.

Бенчмарки показывают, что на одних и тех же численных данных на отсортированном и неотсортированном массивах процедура работает за сопоставимое время. Такой результат достигается за счет гибридного алгоритма в методе IntroSelect.

Benchmark 1 (Random distribution)
SIZE=100000; N=50000;16267990 nanoseconds
-----------------------------------------
Benchmark 2 (sorted array)
SIZE=100000; N=50000;18810270 nanoseconds


![График](chart.png)

# Bloom Filter

Реализация фильтра Блума на Java

Добавлен пакет для структур данных, в котором лежит реализация фильтра Блума.
Создан пакет для hash-функций и их фабрик (для Integer, String и Object). Также есть интерфейс для добавления новых функций/фабрик

## Тесты и анализ результатов
Тесты проверяют, насколько теоретические вероятности ошибок совпадают с теоретическими, а также насколько точно работает функция оценки количества элементов в BitSet.

### Теоретическая вероятность ложного срабатывания
##### Формула:

expectedProbability ≈ (1 - e^(-k * n / m))^k
#### Вывод:

### Вероятность того, что один бит останется 0 после добавления n элементов:
##### Формула:
p_0 = (1 - 1/m)^{k * n} ≈ e^{-k * n / m}.

### Вероятность того, что все k битов для элемента установлены в 1 (ложное срабатывание):
##### Формула:
expectedProbability = (1 - p_0)^k = (1 - e^{-k * n / m})^k.

### Оценка количества элементов
#### Формула:
estimatedCount = -m * ln(1 - X/m) / k,
где X – количество установленных битов в фильтре.

#### Логика:
Если X ≈ m * (1 - e^{-k * n / m}), то можно выразить n через X.


Тесты экспериментально подтвердили точность методов

## Benchmarks
Были проведены следующие тесты производительности:
1) Замеры времени обработки основных методов для примитивов (int) при работе с BloomFilter
![img.png](bloom_filter_put_int.png)
![img_1.png](bloom_filter_might_contain_int_if_true.png)
![img_2.png](bloom_filter_might_contain_int_if_false.png)
2) Замеры времени обработки основных методов для объектов (Integer) при работе с GenericBloomFilter
![img_3.png](generic_bf_put.png)
![img_4.png](generic_bf_might_contain_if_true.png)
![img_5.png](generic_bf_might_contain_if_false.png)
3) Использование памяти (одинаково для обеих реализаций)
![img_6.png](bf_memory_usage.png)


### Анализ
Как показывают данные, реализация без обобщений работает немного быстрее за счет обхода виртуальных вызовов
